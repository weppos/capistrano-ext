unless Capistrano::Configuration.respond_to?(:instance)
  abort "capistrano/ext/multistage requires Capistrano 2"
end

Capistrano::Configuration.instance.load do
  location = fetch(:stage_dir, "config/deploy")

  unless exists?(:stages)
    set :stages, Dir["#{location}/*.rb"].map { |f| File.basename(f, ".rb") }
  end

  stages.each do |name| 
    desc "Set the target stage to `#{name}'."
    task(name) do 
      set :stage, name.to_sym 
      load "#{location}/#{stage}" 
    end 
  end 

  on :load do
    if stages.include?(ARGV.first)
      # Execute the specified stage so that recipes required in stage can contribute to task list
      find_and_execute_task(ARGV.first) if ARGV.any?{ |option| option =~ /-T|--tasks|-e|--explain/ }
    else
      # Execute the default stage so that recipes required in stage can contribute tasks
      find_and_execute_task(default_stage) if exists?(:default_stage)
    end
  end

  namespace :multistage do
    desc "[internal] Ensure that a stage has been selected."
    task :ensure do
      if !exists?(:stage)
        if exists?(:default_stage)
          logger.important "Defaulting to `#{default_stage}'"
          find_and_execute_task(default_stage)
        else
          abort "No stage specified. Please specify one of: #{stages.join(', ')} (e.g. `cap #{stages.first} #{ARGV.last}')"
        end
      end 
    end

    desc "Stub out the staging config files."
    task :prepare do
      FileUtils.mkdir_p(location)
      stages.each do |name|
        file = File.join(location, name + ".rb")
        unless File.exists?(file)
          File.open(file, "w") do |f|
            f.puts "# #{name.upcase}-specific deployment configuration"
            f.puts "# please put general deployment config in config/deploy.rb"
          end
        end
      end
    end
  end

  on :start, "multistage:ensure", :except => stages + ['multistage:prepare']
  
  
  namespace :deploy do
    namespace :web do

      desc <<-DESC
        Present a maintenance page to visitors. Disables your application's web \
        interface by writing a "maintenance_<stage>.html" file to each web server. \
        The servers must be configured to detect the presence of this file, and if \
        it is present, always display it instead of performing the request.

        The file is named according to current stage and stored in your application \
        system folder. This is useful if you want to disable \
        single environments at once. For example, the following command \
        will create the "maintenance_production.html" maintenance file.

          $ cap production deploy:web:disable

        By default, the maintenance page will just say the site is down for \
        "maintenance", and will be back "shortly", but you can customize the \
        page by specifying the REASON and UNTIL environment variables:

          $ cap deploy:web:disable \\
                REASON="hardware upgrade" \\
                UNTIL="12pm Central Time"
        
        The maintenance page is based on the default Capistrano maintenance \
        template called maintenance.rhtml and available in the templates \
        folder. You can provide a custom template either changing \
        the template directory via :template_dir variable or specifying \
        a custom template name with :maintenance_file.

        Further customization will require that you write your own task.
      DESC
      task :disable, :roles => :web, :except => { :no_release => true } do
        require 'erb'
        on_rollback { run "rm #{shared_path}/system/maintenance_#{stage}.html" }

        reason = ENV['REASON']
        deadline = ENV['UNTIL']

        template = File.read(File.join(fetch(:template_dir, File.dirname(__FILE__) + '/templates'), fetch(:maintenance_file, "maintenance.rhtml")))
        result = ERB.new(template).result(binding)

        put result, "#{shared_path}/system/maintenance_#{stage}.html", :mode => 0644
      end

      desc <<-DESC
        Makes the application web-accessible again. Removes the \
        "maintenance_<stage>.html" page generated by deploy:web:disable, which (if your \
        web servers are configured correctly) will make your application \
        web-accessible again.
      DESC
      task :enable, :roles => :web, :except => { :no_release => true } do
        run "rm #{shared_path}/system/maintenance_#{stage}.html"
      end

    end
  end
  
end